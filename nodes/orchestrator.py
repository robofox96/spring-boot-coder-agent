import json
from typing import Literal

from langchain_core.messages import HumanMessage

from states.states import CodeState


def clean_json_string(last_message):
    """
    Cleans the last message string to ensure it is a valid JSON format.
    This function removes any unwanted characters that may prevent JSON parsing.
    """
    # Remove any leading/trailing whitespace and ensure it's a valid JSON string
    cleaned_message = last_message.strip()
    if cleaned_message.startswith("```json"):
        cleaned_message = cleaned_message[8:].strip()  # Remove the ```json prefix
    if cleaned_message.endswith("```"):
        cleaned_message = cleaned_message[:-3].strip()  # Remove the ``` suffix
    return cleaned_message


def implement_coding_plan_node(state: CodeState):
    print("In implementer node")
    """
    This node implements the coding plan generated by the code planner.
    It reads the coding plan from the state and applies the changes to the codebase.
    """
    if not state["impl_started"]:
        state["impl_started"] = True
        state["cycles"] -= 1

        last_message = state["messages"][-1].content
        last_message = clean_json_string(last_message)
        try:
            state["coding_plan"] = json.loads(last_message)
        except json.JSONDecodeError:
            state["messages"].append(HumanMessage(content="Failed to parse the coding plan. Please check the coding plan format."))
            state["coding_plan"] = {"steps": []}

        print("Coding plan loaded:", state["coding_plan"])
        state["coding_impl"] = {}
        for step in state["coding_plan"]["steps"]:
            state["coding_impl"][step["id"]] = {
                "coding_started": False,
                "messages": [],
                "coding_step": step["id"],
                "overall_requirement": state["coding_plan"]["summary"],
                "coding_done": False
            }

    state["impl_done"] = True

    # Simulating applying the coding plan
    for step, val in state["coding_impl"].items():
        if val["coding_done"] is False:
            state["current_implementation_step"] = val["coding_step"]
            state["impl_done"] = False
            state["overall_messages"].extend(state["messages"])
            state["messages"] = []

    return state

def decide_next_step_node(state: CodeState) -> Literal["code_generator_node", "builder_node", "__end__"]:
    print("In decision node")
    """
    This node decides the next step based on the current state.
    It checks if coding is done and returns the appropriate message.
    """
    if state["cycles"] <= 0:
        state["overall_messages"].append(HumanMessage(content="Maximum cycles reached. Ending process."))
        return "__end__"
    if state["impl_done"] is True:
        return "builder_node"
    return "code_generator_node"

# print (implement_coding_plan_node({"coding_plan": {"steps": [{"step": 1, "description": "Update pom.xml"}]},
#                             "impl_started": False,
#                             "impl_done": False,
#                             "coding_impl": {},
#                             "feature_requirement": "Implement a new feature.",
#                            "current_implementation_step": 0, "messages": [HumanMessage("Hello")], "planning_started": False }))